import { ConfiguratorDisplayService } from './../Services/configuratorDisplay.service';
import { HttpClient } from '@angular/common/http';
import { Component, HostListener, Input, OnInit, ViewChild, OnDestroy, OnChanges, SimpleChanges } from '@angular/core';
import { DxDataGridComponent } from 'devextreme-angular';
import CustomStore from 'devextreme/data/custom_store';
import { Observable, Subscription } from 'rxjs';
import { SubformsAGOSELPANEL } from '../Models/SubformsAGOSELPANEL.model';
import { FilterSearchService } from '../Services/filtersSearch.service';
import { RetreiveHttpDataService } from '../Services/retreiveHttpData.service';
import { RoutingService } from '../Services/routingService.service';
import { speccode } from '../Shared/Constantes';
import { environment } from 'src/environments/environment';

@Component({
  selector: 'app-multi-column-grid',
  templateUrl: './multi-column-grid.component.html',
  styleUrls: ['./multi-column-grid.component.css']
})
export class MultiColumnGridComponent implements OnInit, OnDestroy, OnChanges {
  @ViewChild(DxDataGridComponent, { static: false }) dataGrid: any;
  
  apiLink = environment.apiLink;  
  
  //Data source for the data grid
  dataSource: any;

  //Variable to retreive columns information
  columnsA_SELLISTUPDERGO: any;
  columnsA_SELLISTUPDERGOSubscription: Subscription;
  
  //Varible boolean used to identify if it's the first load or not to not launch onContentReady when scrolling
  isFirstLoad: boolean;
  isFirstLoadSubscription : Subscription;

  isFirstLoadFilter : number;
  isFirstLoadFilterSubscription : Subscription;
  
  isFirstLoad2: boolean;
  

  windowWidth : number; 

  @Input() filter!: Observable<void>;
  filterSubscription: Subscription;

  constructor(private retreiveHttpDataService: RetreiveHttpDataService,
              private httpClient: HttpClient,
              private filterSearchService: FilterSearchService,
              private routingService: RoutingService,
              private configuratorDisplayService: ConfiguratorDisplayService) { 
    

    this.windowWidth = window.innerWidth;

    this.columnsA_SELLISTUPDERGOSubscription = new Subscription();
    
    this.isFirstLoad = true;
    this.isFirstLoadSubscription = new Subscription();

    this.isFirstLoadFilter = 0;
    this.isFirstLoadFilterSubscription = new Subscription();

    this.isFirstLoad2 = true;
    
    this.filterSubscription = new Subscription();

      //Filling the dataSource with a new customStore
      this.dataSource = new CustomStore({ 
        key: "recno",
        byKey: async function (key: any): Promise<any> {
          if(retreiveHttpDataService.columnsA_SELLISTUPDERGO==""){
            return new Promise((resolve, reject) => {}).then(() => {
              return {
                data: {},
                totalCount: 0
              };
            });
          }else{
            let httpBody = new FormData();
            httpBody.append('session', retreiveHttpDataService.responseInfos.session);
            httpBody.append('catalog', retreiveHttpDataService.responseOptions.CatCode);
            httpBody.append('family', retreiveHttpDataService.responseOptions.FamCode);
            httpBody.append('criterid', '1');
            httpBody.append('recno', key);
            httpBody.append('Action', 'Q_SELLISTCHANGE');
            return httpClient.post<any[]>(environment.apiLink, httpBody)
                  .toPromise();
          }     
        },
        load: async function (loadOptions: any): Promise<any> {
          
            if(!filterSearchService.getFiltred()){
              filterSearchService.filtredToTrue();
              await routingService.processClick('Filter', loadOptions['filter']);
              //Return a empty data to not generate an error, the real data will be generated by rebuilding the configurator when calling the routingService.processClick('Filter', loadOptions['filter']);
              return new Promise((resolve, reject) => {}).then(() => {
                return {
                  data: {},
                  totalCount: 0
                };
              });
            }
            else if(retreiveHttpDataService.columnsA_SELLISTUPDERGO==""){
              return new Promise((resolve, reject) => {}).then(() => {
                return {
                  data: {},
                  totalCount: 0
                };
              });
            }
            else{
                let httpBody = new FormData();
                httpBody.append('offset', loadOptions['skip']);
                httpBody.append('limit', loadOptions['take']);
                httpBody.append('session', retreiveHttpDataService.responseInfos.session);
                httpBody.append('ACE_GUI', 'Custom');
                httpBody.append('startingcata', retreiveHttpDataService.responseOptions.CatCode);
                httpBody.append('family', retreiveHttpDataService.responseOptions.FamCode);
                httpBody.append('criterid', '1');
                httpBody.append('options', '2');
                httpBody.append('Action', 'Q_SELLISTUPDERGO');
                return httpClient.post<any[]>(environment.apiLink, httpBody)
                    .toPromise()
                    .then((data: any) => {
                        const command = data.command;
                        if(command === 'A_ERROR'){
                            retreiveHttpDataService.modifyResponseQping(data.options);
                        } 
                        const dataArray: any = data.response.data;
                        //replace empty values with ? when it is a lax mode
                        let hasLaxMode : Map<string, boolean> = new Map();
                        let subforms: SubformsAGOSELPANEL[];
                        if(Array.isArray(retreiveHttpDataService.contentAGOSELPANEL.subforms)){
                          subforms = retreiveHttpDataService.contentAGOSELPANEL.subforms;
                        } 
                        else{
                          subforms = [retreiveHttpDataService.contentAGOSELPANEL.subforms];
                        } 
                        subforms.forEach(subform => {
                          subform.formfields.forEach((element: any) => {
                            if(element.Pattern != ''){
                              hasLaxMode.set(element.Code,element.Pattern.includes('E')?true:false);
                            } 
                          });
                        });
                        dataArray.forEach((rowElement:any, index: number) => {
                          retreiveHttpDataService.columnsA_SELLISTUPDERGO.forEach((column : any) => {
                            if((rowElement[column.Code]=='' || rowElement[column.Code]==null) && hasLaxMode.get(column.Code)){
                              rowElement[column.Code] = '?';
                              dataArray[index] = rowElement;
                            } 
                          });
                        });
                        return {
                            data: dataArray,
                            totalCount: +data.response.totalRows
                        };
                    })
                    .catch( (error : any)=> { throw 'Data Loading Error: new CustomStore' + error});
            } 
            
        }
      });
  }


  ngOnInit(): void {

    //Subscribe to columnsA_SELLISTUPDERGOSubject to get columns name
    this.columnsA_SELLISTUPDERGOSubscription = this.retreiveHttpDataService.columnsA_SELLISTUPDERGOSubject.subscribe(data =>{
      this.columnsA_SELLISTUPDERGO = this.toArray(data);
    });
    this.retreiveHttpDataService.emitColumnsA_SELLISTUPDERGO();

    this.filterSubscription = this.filter.subscribe(async (data)=>{
      await this.dataGrid.instance.filter(data);
    });

    this.isFirstLoadFilterSubscription = this.configuratorDisplayService.isFirstLoadFilterSubject.subscribe(data => {
      this.isFirstLoadFilter = data;
    });
    this.configuratorDisplayService.emitIsFirstLoadFilter();

    this.isFirstLoadSubscription = this.configuratorDisplayService.isFirstLoadSubject.subscribe(data => {
      this.isFirstLoad = data;
    });
    this.configuratorDisplayService.emitIsFirstLoad();

  }

  ngOnChanges(changes: SimpleChanges): void {
  }

  ngOnDestroy(): void {
    this.filterSubscription.unsubscribe();
    this.columnsA_SELLISTUPDERGOSubscription.unsubscribe();
    this.isFirstLoadFilterSubscription.unsubscribe();
    this.isFirstLoadSubscription.unsubscribe();
  }

  async onContentReady(): Promise<void>{

    if(this.isFirstLoad){
      await this.selectFirstItemFirstLoad();
    } 
    this.configuratorDisplayService.isFirstLoadToFalse();

    this.configuratorDisplayService.incrementIsFirstLoadFilter();
    if(this.isFirstLoadFilter == 2){
      await this.selectFirstItemFirstLoad();
    }
    

  }


  async selectFirstItemFirstLoad(): Promise<void>{
    this.dataGrid.instance.selectRowsByIndexes([0]);
    const selectedItem = await this.dataGrid.instance.getSelectedRowsData()[0];
    this.filterSearchService.selectedItemFilling(selectedItem);
  } 


  selectFirstItem(): void{
    this.dataGrid.instance.selectRowsByIndexes([0]);
    this.getSelectedItem();
  } 

  async getSelectedItem(): Promise<void>{
    const selectedItem = await this.dataGrid.instance.getSelectedRowsData()[0];
    const dataSelectedItem = await this.dataSource.byKey(selectedItem.recno);
    this.retreiveHttpDataService.updateSelectBoxDatas(dataSelectedItem);
    const specResponse = await this.getItemSpec();
    this.retreiveHttpDataService.modifySpecAspec(specResponse.spec);
    this.filterSearchService.selectedItemUpdate(dataSelectedItem.datas.criteria);
  }

    //Void called when item is selected in the datagrid, it fill the selectedItems array with data of the selected item => this array is used as values to fill the select boxs
  onSelectItem(): void{
      if(!this.isFirstLoad2){
  
        this.getSelectedItem();
      } 
      this.isFirstLoad2=false;
  }


  //Function return the data grid height
  getDataGridHeight():string{
      if(this.columnsA_SELLISTUPDERGO==''){
        return '0px';
      } else{
        if(this.windowWidth>400){
          return '380px';
        } else{
          return '200px';
        } 
      } 
  } 

  columnHidingEnabled(){
    if(this.windowWidth>1000){
      return false;
    }
    else{
      return true;
    }
  }


  allowColumnResizing(){
    if(this.windowWidth>1000){
      return true;
    }
    else{
      return false;
    }
  }
  
  async getItemSpec(): Promise<any>{
    let httpBody = new FormData();
    httpBody.append('session', this.retreiveHttpDataService.responseInfos.session);
    httpBody.append('catalog', this.retreiveHttpDataService.responseOptions.CatCode);
    httpBody.append('family', this.retreiveHttpDataService.responseOptions.FamCode);
    httpBody.append('speccode', speccode);
    httpBody.append('Action', 'Q_SPEC');
    return this.httpClient.post<any[]>(this.apiLink, httpBody)
                .toPromise();   
  } 
  

  @HostListener('window:resize', ['$event'])
  onResizeWindow(event: any) {
     this.windowWidth = window.innerWidth;
  }


  toArray(object: any): any{
    if(Array.isArray(object)){
      return object
    }else{
      let array : any[]=[];
      array[0]= object;
      return array;
    }
  }

}
